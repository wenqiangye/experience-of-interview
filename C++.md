# C++ 面经整理

1. c++ 程序编译过程
   预处理->编译，优化->汇编->链接
   预处理：(预处理器指令)宏展开，处理条件编译指令，#if,#ifdef等，#include指令,删除注释，加入行号和文件标识等，保留#pragma编译器指令
   编译优化：词法分析，语法分析，语义分析，代码优化，主要是生成汇编代码.s
   汇编：将汇编代码.s翻译成机器指令.o或.obj目标文件
   链接：产生.out或.exe可执行文件。（静态链接和动态链接）链接是将所有的.o文件和库（动态库、静态库）链接在一起，得到可以运行的可执行文件（Windows的.exe文件或Linux的.out文件）等 。静态链接是 将各个模块的obj和库链接成 **一个完整的可执行程序** ；而动态链接是程序在运行的时候寻找动态库的函数符号（重定位），即 **DLL不必被包含在最终的exe文件中** ；
   
2. 讲述一下c++内存的结构

   栈，堆，全局/静态存储区，常量存储区，代码区。

   - **栈**：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。栈从高地址向低地址增长。是一块连续的空间。栈一般分配几M大小的内存。
   - **堆**：动态申请的内存空间，就是由 malloc （new）分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。堆从低地址向高地址增长。一般可以分配几个G大小的内存。
   - 在堆栈之间有一个 共享区（文件映射区）
   - 全局区/静态存储区：存放全局变量和静态变量，程序运行结束操作系统自动释放
   - **代码区（.text 段）**：存放程序执行代码的一块内存区域。**只读，不允许修改**，但可以执行。编译后的二进制文件存放在这里。
   
3. 栈和堆的区别

   **申请方式的不同**。 栈由系统自动分配，而堆是人为申请开辟;
   **申请大小的不同**。 栈获得的空间较小，而堆获得的空间较大;
   **申请效率的不同**。 栈由系统自动分配，速度较快，而堆一般速度比较慢;
   **存储的内容不同**。堆一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。
   栈在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
   
4. 变量的区别

   **全局变量、局部变量、静态全局变量、静态局部变量**
   全局变量：定义在函数外面的变量。局部变量：函数内定义的变量。静态变量，前面加了static的变量。全局变量和静态变量存储在常量区（静态存储区）。局部变量存储在栈区。局部变量一般不初始化，全局变量和静态变量都初始化为0，有一个初始的值。
   对于C语言： 静态变量和全局变量均在**编译期进行初始化**，即初始化发生在任何代码执行之前。
   对于C++： 静态变量和全局变量**仅当首次被使用的时候才进行初始化**
   
5. 作用域

   全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。
   全局作用域。**全局变量**只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。会一直存在到程序结束。
   **静态全局变量：**全局作用域+文件作用域，所以无法在其他文件中使用。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
   **局部变量：**具有局部作用域。比如函数的参数，函数内的局部变量等等；它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被销毁，其所占用的内存也被收回。
   **静态局部变量：**具有局部作用域。它只被初始化一次， 直到程序结束。自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。
   
6. 内存对齐：

   什么是内存对齐？内存对齐的原则？为什么要内存对齐？有什么优点？
   内存对齐：编译器将程序中的每个“数据单元”安排在**字的整数倍**的地址指向的内存之中
   结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；
   结构体每个成员相对于结构体首地址的偏移量 （offset）都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；
   结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。

   主要是硬件设备的原因，某些硬件设备只能存取对齐数据。存取非对齐的数据可能会引起异常。

   提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取
   
7. 内存泄露

   失去了对某些内存的控制权。造成了内存的浪费。常指堆内存泄露，堆是动态分配的，用户控制，如果使用不当，比如因为异常未delete 数据，会产生内存泄露。
   
8. 防止内存泄露

   1. 内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。（说明：但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况）
   2. 智能指针。
   
9. 深拷贝与浅拷贝

   c++默认的拷贝构造函数是浅拷贝。当数据成员中没有指针时，浅拷贝是可行的；但**当数据成员中有指针时，如果采用简单的浅拷贝**，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。深拷贝会在**堆内存中另外申请空间来储存数据，而不是一个简单的赋值过程**，从而也就解决了指针悬挂的问题。

10. 虚拟内存

物理内存：物理内存实际上是CPU中能直接寻址的地址线条数。由于物理内存是有限的，例如32位平台下，寻址的大小是4G，并且是固定的。内存很快就会被分配完，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的。

虚拟内存：在进程创建的时候，系统都会给每个进程分配4G的内存空间，这其实是虚拟内存空间。进程得到的这4G虚拟内存，进程自身以为是一段连续的空间，而实际上，通常被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，需要的时候进行数据交换。

​	当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。
​	另外在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。

​	可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）

优点：

既然每个进程的内存空间都是一致而且固定的（32位平台下都是4G），所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际内存地址，这交给内核来完成映射关系。

当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存

在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。这样就可以有效地利用我们的物理内存

11. auto，decltype

auto 关键字：自动类型推导，编译器会在 **编译期间** 通过初始值推导出变量的类型，通过 **auto 定义的变量必须有初始值。**

decltype 是“declare type”的缩写，译为“声明类型”。和 auto 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto

```cpp
auto var = val1+val2
decltype (val1+val2) val = 0;
```

12. lambada表达式

lambda 表达式，又被称为 lambda 函数或者 lambda 匿名函数。

```cpp
[capture list] (parameter list) -> return type
{
   function body;
};

```

- capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表，通常为空。
- return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。

```cpp
sort(arr,arr+4,[=](int x,int y)-> bool{ return x<y; })
```

13. 范围for语句

```cpp
for(declaration:expression) {
	statement
}
```

expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、vector ，string等，这些类型的共同特点是拥有能返回迭代器的 beign、end 成员。

declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用 auto 类型说明符。

14. 左值引用，右值引用，万能引用。

左值和右值都是表达数据的表达式，右值是不可取地址的，比如常数，x+y，以及函数的返回值。
左值引用和右值引用(c++11)就是分别给左右值取别名。右值引用引用右值，把右值存储在一个特定的位置，然后可以对这个右值引用变量取地址。
左值引用不能之间引用右值，但是const左值引用既可以引用左值，也可以引用右值。
右值引用可以引用被move的左值。std::move将左值强制转换为右值.
解决传值返回和拷贝问题。
移动语义：将一个对象的资源移动到另一个对象。
移动构造直接转移资源，比拷贝构造效率高。拷贝构造，深拷贝需要开辟空间。

15. c++智能指针

智能指针是**RAII(Resource Acquisition Is Initialization，资源获取即初始化)**机制对普通指针进行的一层封装。这样使得智能指针的行为动作像一个指针，本质上却是一个对象，这样可以方便管理一个对象的生命周期。auto_ptr、unique_ptr、shared_ptr 和 weak_ptr。其中，auto_ptr 在 C++11已被摒弃，在C++17中已经移除不可用。
unique_ptr**没有复制构造函数，不支持普通的拷贝和赋值操作**。因为unique_ptr独享被管理对象指针所有权。unique_ptr虽然不支持普通的拷贝和赋值操作，但却可以**将所有权进行转移，使用std::move方法**即可。
unique**最常见的使用场景，就是替代原始指针，为动态申请的资源提供异常安全保证**。
shared_ptr**使用引用计数实现对同一块内存的多个引用**。在最后一个引用被释放时，指向的内存才释放。
当对象的所有权需要共享(share)时，share_ptr**可以进行赋值拷贝**。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。
**不能将一个原始指针初始化多个shared_ptr**，因为p1,p2都要进行析构删除，这样会造成原始指针p0被删除两次，自然要报错。

```cpp
void f2() {
    int *p0 = new int(1);
    shared_ptr<int> p1(p0);
    shared_ptr<int> p2(p0);
    cout<<*p1<<endl;
}
```

​	**shared_ptr最大的坑就是循环引用**，为避免循环引用导致的内存泄露，就需要使用 weak_ptr。**weak_ptr 并不拥有其指向的对象**，也就是说，让 **weak_ptr 指向 shared_ptr 所指向对象，对象的引用计数并不会增加**。**因此不能保证所管理的对象一定存在。**用于检查所管理的资源是否已经被释放（**expired()**函数），以及协助 shared_ptr 防止循环引用。
​    shared_ptr 的**引用计数是通过原子操作**实现的，即**多线程环境下可以保证线程安全**。在 std::shared_ptr 中，使用 **std::atomic 类型来实现引用计数的原子操作**。该类型是 **C++11 标准库**中提供的，支持原子类型加、减、读、写等操作

​	**智能指针指向的对象的线程安全问题，智能指针没有做任何保障**

​	**1）同一个shared_ptr被多个线程“读”是安全的；**

​	**2）同一个shared_ptr被多个线程“写”是不安全的；**

​	**3）共享引用计数的不同的shared_ptr被多个线程”写“ 是安全的；**

​	读的时候，比如把智能指针赋值给另一个智能指针，这个不会修改原始指针的指向，只会修改引用计数，而修改引用计数这个操作是原子的，所以读操作就是线程安全的；

​	写的时候，需要做两个事情，先修改原始指针然后再引用计数，这两个步骤是没有加锁保护的，所以这两个操作加起来就不是原子的。比如swap函数：

16. delete函数和default函数
    - delete 函数：= delete 表示该函数不能被调用。
    - default 函数：= default 表示编译器生成默认的函数，例如：生成默认的构造函数。

17. const与define区别

#define是在编译的**预处理阶段**起作用，而const是在 **编译、运行**的时候起作用
#define只是**简单的字符替换，没有类型检查,存在边界的错误；**const对应**数据类型，进行类型检查；**                                                                                                       #define只是进行展开，有多少地方使用，就替换多少次，**它定义的宏常量在内存中有若干个备份,占用代码段空间；**const定义的只读变量在程序运行过程中**只有一份备份，占用数据段空间。**

**const常量可以进行调试的**，**define是不能进行调试的**，因为在预编译阶段就已经替换掉了。                                                                                                                                                                                                              **const不足的地方，是与生俱来的，const不能重定义，而#define可以通过#undef取消某个符号的定义，再重新定义。**

**define可以用来防止头文件重复引用，而const不能;**

**const用于类成员变量的定义，只要一定义，不可修改。define 不可用于类成员变量的定义，但是可以用于全局变量。**

const采用一个普通的常量名称，define可以采用表达式作为名称；

18. c和c++的区别

    面向对象和面向过程：

    面向过程编程就是分析出解决问题的步骤，然后把这些步骤一步一步的实现，使用的时候一个一个的依次调用就可以了。

    面向对象编程就是把问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。

    **区别和联系**：

    ​	动态内存管理：**c:malloc和free来进行堆内存的分配和释放**，**c++:new和delete来管理堆内存**

    ​	**强制类型转换上也不一样**，C的强制类型转换使用()小括号里面加类型进行类型强转的，而C++有四种自己的类型强转方式，分别是const_cast，static_cast，reinterpret_cast和dynamic_cast；

    ​	**C++还支持namespace名字空间**，可以让用户自己定义新的名字空间作用域出来，**避免全局的名字冲突**问题。

    ​	C++ 对 C 的“增强”，表现在以下几个方面：**类型检查**更为严格。增加了**面向对象**的机制、**泛型编程**的机制（Template）、**异常处理**、**运算符重载**、**标准模板库（STL）**、**命名空间（避免全局命名冲突）**。

19. c++面向对象封装，继承，多态

* 封装：类，属性和方法都在类里，通过接口访问，降低耦合
* 继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。
* 多态：相同的方法调用，不同的实现方式，一个接口，多种方法，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。
  * 虚函数，方法重写（动态多态）通过基类类型的引用或指针调用虚函数
  * 静态多态：编译期间的多态，编译器根据函数实参的类型推断出要调用那个函数（函数重载，函数模板（泛型编程））

20. 重载、重写、隐藏的区别

    **重载**：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，**重载不关心函数返回类型**。

    **隐藏**：是指派生类的函数屏蔽了与其同名的基类函数，主要**只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。**

    **重写(覆盖)**：是指**派生类中存在重新定义的函数**。**函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同**。派生类调用时会调用派生类的重写函数，不会调用被重写函数。**重写的基类中被重写的函数必须有 virtual 修饰。**

21. 什么是多态，多态如何实现？

    ***多态***：多态就是**不同继承类的对象**，对**同一消息做出不同的响应**，**基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。**在基类的函数前加上 **virtual 关键字**，**在派生类中重写该函数**，**运行时将会根据对象的实际类型来调用相应的函数。**如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

    ***实现方法***：多态是通过**虚函数**实现的，**虚函数的地址保存在虚函数表**中，**虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中**。

    ***实现过程***：

    1. 在类中用 virtual 关键字声明的函数叫做虚函数；
    2. **存在虚函数的类都有一个虚函数表**，当**创建一个该类的对象时**，该**对象有一个指向虚函数表的虚表指针**（虚函数表和类对应的，虚表指针是和对象对应）；
    3. 当**基类指针指向派生类对象**，**基类指针调用虚函数时，基类指针指向派生类的虚表指针**，由于该**虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。**

22. 静态多态与动态多态：

    1. 静态多态：也称为编译期间的多态，编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。
    2. 动态多态（动态绑定）：即运行时的多态，**在程序执行期间(非编译期)判断所引用对象的实际类型**，根据其实际类型调用相应的方法。：
       ● **基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行重写。**
       ● **通过基类对象的指针或者引用调用虚函数。**

23. 虚函数和纯虚函数：

    **被 virtual 关键字修饰的成员函数，就是虚函数。纯虚函数在类中声明时，加上 =0；**

    **含有纯虚函数的类称为抽象类**（只要含有纯虚函数这个类就是抽象类），**类中只有接口，没有具体的实现方法；**

    **继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。**

    - 抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；
    - 可以声明抽象类指针，可以声明抽象类的引用；
    - 子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。
    - **析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。**

24. 虚函数实现机制：

    **虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表**。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。

    虚函数表：

    - 虚函数表存放的内容：**类的虚函数的地址。**
    - 虚函数表建立的时间：**编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。**
    - 虚表指针保存的位置：**虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。**

    **虚函数表和类绑定，虚表指针和对象绑定。**即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。

25. 单继承和多继承的虚函数表结构：

    **编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。**
    **如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。**
    **如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中。**
    **如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。**

26. 为什么构造函数不能为虚函数

    虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；**若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间**，**更没有虚函数表地址用来调用虚函数**——构造函数了。

27. 为什么析构函数可以为虚函数，如果不设为虚函数可能会存在什么问题？

    防止内存泄露，delete p（基类）的时候，它很机智的先执行了派生类的析构函数，然后执行了基类的析构函数。

    如果**基类的析构函数不是虚函数**，在**delete p（基类）时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象**，这样就会造成内存泄露。

    子类B继承自基类A；A *p = new B; delete p;
    1） 此时，**如果类A的析构函数不是虚函数**，那么**delete p；将会仅仅调用A的析构函数，****只释放了B对象中的A部分，而派生出的新的部分未释放掉。**
    2） 如果**类A的析构函数是虚函数**，**delete p; 将会先调用B的析构函数，再调用A的析构函数，释放B对象的所有空间。**
    补充： B *p = new B; delete p;时也是先调用B的析构函数，再调用A的析构函数。

28. 不能声明为虚函数的有哪些
    1. 静态成员函数：类的静态成员函数是该类共用的，与该类的对象无关，静态函数里没有this指针，所以不能为虚函数。
    2. 类外的普通函数
    3. 构造函数：构造函数是为了构造对象的，所以在调用构造函数时候必然知道是哪个对象调用了构造函数，所以构造函数不能为虚函数。
    4. 友元函数：友元函数与该类无关，没有this指针，所以不能为虚函数。

29. C++ explicit关键字

    explicit关键字**只能用于修饰只有一个参数的类构造函数**, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).
    **如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了.**
    **除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效**, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数

30. c和c++中static的区别
    - 在 C 语言中，使用 static 可以定义局部静态变量、外部静态变量、静态函数
    - 在 C++ 中，使用 static 可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为 C++中有类的概念，静态成员变量、静态成员函数都是与类有关的概念

31. 静态成员变量在类中的使用注意事项（定义、初始化和使用）
    1. 静态成员变量是在**类内进行声明**，在**类外进行定义和初始化**，在**类外进行定义和初始化的时候不要出现 static关键字和private、public、protected 访问规则**。
    2. 静态成员变量**相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。**
    3. 静态成员变量**可以作为成员函数的参数**，而**普通成员变量不可以**。
    4. **静态成员函数不能调用非静态成员变量或者非静态成员函数**，因为**静态成员函数没有 this 指针**。静态成员函数做为类作用域的全局函数。
    5. **静态成员函数不能声明成虚函数（virtual）、const 函数和 volatile 函数。**

32. static 全局变量和普通全局变量的异同

    **相同点：**

    存储方式：**普通全局变量和 static 全局变量都是静态存储方式。**
    **不同点：**

    作用域：**普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；**静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。**由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。
    **初始化：**静态全局变量只初始化一次，防止在其他文件中使用。**

33. const作用及用法

    作用：


​			const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。
​			const 修饰函数参数，使得传递过来的函数参数的值不能改变。
​			const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。

​		const成员变量：

​			**const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。**
​			**const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。**
​		const 成员函数：

​			**不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。**
​			**不能调用非常量成员函数，以防修改成员变量的值。**

32. define和const的区别（见17）

33.  define 和typedef的区别

    原理：#define 作为预处理指令，在**编译预处理时进行替换操作**，不作正确性检查，只有**在编译已被展开的源程序时才会发现可能的错误并报错**。typedef 是**关键字**，在**编译时处理，有类型检查功能**，用来给一个已经存在的类型一个别名，**但不能在一个函数定义里面使用 typedef** 

    功能：typedef 用来定义类型的别名，方便使用。#define 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。

    作用域：**#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用**，**而 typedef 有自己的作用域。**

    指针的操作：typedef 和 #define 在处理指针时不完全一样

    const int * 常量指针；int * const 指针常量

    ```cpp
    #include <iostream>
    #define INTPTR1 int *
    typedef int * INTPTR2;
    
    using namespace std;
    
    int main()
    {
        INTPTR1 p1, p2; // p1: int *; p2: int
        INTPTR2 p3, p4; // p3: int *; p4: int *
    
        int var = 1;
        const INTPTR1 p5 = &var; // 相当于 const int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。
        const INTPTR2 p6 = &var; // 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。
        return 0;
    }
    
    ```

34. inline作用及使用方法

    inline 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。

    工作原理：在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。

    **普通函数是将程序执行转移到被调用函数所存放的内存地址**，**当函数执行完后，返回到执行此函数前的地方。** **转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。**

35. 宏定义和inline的区别

    ​	内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。
    ​	内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。
    ​	宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。

36. new delete，malloc free

    new 是 C++ 中的关键字，用来动态分配内存空间

    malloc ：成功申请到内存，返回指向该内存的指针；分配失败，**返回 NULL 指针。**

    new ：内存分配成功，返回该对象类型的指针；分配失败，**抛出 bac_alloc 异常**。

    区别：

    - malloc、free 是库函数，而new、delete 是关键字。
    - new 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc 在申请空间时，需要确定所申请空间的大小。
    - new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针。
    - new 分配失败时，会抛出 bad_alloc 异常，malloc 分配失败时返回空指针。
    - 对于自定义的类型，**new 首先调用 operator new() 函数申请空间**（**底层通过 malloc 实现**），然后调用构造函数进行初始化，最后返回自定义类型的指针；**delete 首先调用析构函数，然后调用 operator delete() 释放空间（底层通过 free 实现）**。malloc、free 无法进行自定义类型的对象的构造和析构。
    - new 操作符从自由存储区上为对象动态分配内存，而 malloc 函数从堆上动态分配内存。（**自由存储区不等于堆**）

37. malloc的原理？malloc的底层实现？

    原理：

    - 当开辟的空间小于 128K 时，调用 brk() 函数，通过移动 _enddata 来实现；
    - 当开辟空间大于 128K 时，调用 mmap() 函数，通过在虚拟地址空间中开辟一块内存空间来实现。

    底层实现：

    - brk() 函数实现原理：向高地址的方向移动指向数据段的高地址的指针 _enddata。
    - mmap 内存映射原理：
      1.进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域；
      2.调用内核空间的系统调用函数 mmap()，实现文件物理地址和进程虚拟地址的一一映射关系；
      3.进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。

38. c和c++中struct的区别：

    ​	在 **C 语言中 struct 是用户自定义数据类型**；在 **C++ 中 struct 是抽象数据类型，支持成员函数的定义**。
    ​	**C 语言中 struct 没有访问权限的设置，是一些变量的集合体，不能定义成员函数**；**C++ 中 struct 可以和类一样，有访问权限，并可以定义成员函数**。
    ​	**C 语言中 struct 定义的自定义数据类型，在定义该类型的变量时，需要加上 struct 关键字**，例如：struct A var;，定义 A 类型的变量；**而 C++ 中，不用加该关键字，例如：A var;**

    ​	**为了兼容c语言，c++保留struct。**

39. struct和union的区别

    union 是联合体，struct 是结构体。

    - 联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，**联合体只有一个有效的成员**；而结构体所有的成员都有效。
    - **对联合体的不同成员赋值，将会对覆盖其他成员的值**，而对于结构体的对不同成员赋值时，相互不影响。
    - **联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小**；结构体分配内存的大小遵循内存对齐原则。

40. class和struct的异同：

    - struct 和 class 都可以自定义数据类型，也支持继承操作。
    - struct 中默认的访问级别是 public，默认的继承级别也是 public；class 中默认的访问级别是 private，默认的继承级别也是 private。
    - 当 **class 继承 struct 或者 struct 继承 class** 时，**默认的继承级别取决于 class 或 struct 本身**，class（private 继承），struct（public 继承），即**取决于派生类的默认继承级别**。

41. volatile

42. extern C的作用？

    extern "C"的主要作用就是为了能够**正确实现C++代码调用其他C语言代码**。加上extern "C"后，会**指示编译器这部分代码按C语言（而不是C++）的方式进行编译**。**由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中**，**而不仅仅是函数名**；**而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名**。

    ```cpp
    // 可能出现在 C++ 头文件<cstring>中的链接指示
    extern "C"{
        int strcmp(const char*, const char*);
    }
    
    ```

43. sizeof(1==1) 在 C 和 C++ 中分别是什么结果？

    C 语言代码：4

    C++ 代码：1（布尔值大小）

44. memcpy函数的底层原理？

45. strcpy函数有什么缺陷？

46. auto类型推导的原理？

    **编译器根据初始值来推算变量的类型**，要求用 **auto 定义变量时必须有初始值**。**编译器推断出来的 auto 类型有时和初始值类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。**

47. malloc一次性最大能申请多大内存空间？

    

48. public、protected、private的区别？

    第一: private,public,protected的访问范围：

    private: **只能由该类中的函数、其友元函数访问，不能被任何其他访问，该类的对象也不能访问**
    protected: **可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问**
    **public: 可以被该类中的函数、子类的函数、其友元函数访问，也可以由该类的对象访问**
    第二:类的继承后方法属性变化:

    **使用private继承，父类的所有方法在子类中变为private;**
    **使用protected继承，父类的protected和public方法在子类中变为protected，而private方法不变;**
    **使用public继承，父类中的方法属性不发生改变;**

49. 什么是指针？指针的大小及用法？

    **指针**： 指向另外一种类型的复合类型。
    **指针的大小**： 在 64 位计算机中，指针占 8 个字节空间。

50. 什么是野指针和悬空指针？

    悬空指针：
    若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。

    野指针：

    “野指针”是指不确定其指向的指针，未初始化的指针为“野指针”。

51. c++ 11 nullptr比NULL优势？

    - NULL：**预处理变量，是一个宏，它的值是 0，定义在头文件 中，即 #define NULL 0。**
    - nullptr：**C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。**
    - nullptr**有类型，类型是 typdef decltype(nullptr) nullptr_t;，使用 nullptr 提高代码的健壮性。**
      函数重载：**因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现，不知和哪一个函数匹配的情况；**但是传递实参 nullptr 就不会出现这种情况。

52. 指针和引用的区别？

    指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。**（是否可变）**
    指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。**（是否占内存）**
    指针可以为空，但是引用必须绑定对象。**（是否可为空）**
    指针可以有多级，但是引用只能一级。**（是否能为多级）**

53. 指针常量和常量指针？

    **指针常量的本质上是个常量，只不过这个常量的值是一个指针。**

    ​	指针常量的值是指针，这个值因为是常量，所以**指针本身不能改变。** **指针的内容可以改变。**

    **常量指针本质上是个指针，只不过这个指针指向的对象是常量。**

    ​	**指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址**，之所以叫做常量指针，是**限制了通过这个指针修改变量的值**。虽然**常量指针指向的对象不能变化**，**可是因为常量指针本身是一个变量，因此，可以被重新赋值。**

54. 函数指针和指针函数？

    本质不同
    1.指针函数本质是一个函数，其返回值为指针。
    2.函数指针本质是一个指针变量，其指向一个函数。
    定义形式不同
    1.指针函数：int* fun(int tmp1, int tmp2); ，这里* 表示函数的返回值类型是指针类型。
    2.函数指针：int (*fun)(int tmp1, int tmp2);，这里 表示变量本身是指针类型。

55. 如何判断结构体是否相等？能否用memcmp函数判断结构体相等？

    **重载操作符==**，不能， **memcmp 函数是逐个字节进行比较的**，**而结构体存在内存空间中保存时存在字节对齐，字节对齐时补的字节内容是随机的，会产生垃圾值，所以无法比较。**

56. 参数传递时，值传递、引用传递、指针传递的区别？

    参数传递的三种方式：

    **值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。**
    **指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后，实参和形参是不同的指针，通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。**
    **引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。**

57. include " " 和 <> 的区别

    - 查找文件的位置：**include<文件名>在标准库头文件所在的目录中查找**，如果没有，再到当前源文件所在目录下查找；**#include"文件名" 在当前源文件所在目录中进行查找**，如果没有；再到系统目录中查找。
    - **使用习惯：对于标准库中的头文件常用 include<文件名>，对于自己定义的头文件，常用 #include"文件名"**

58. 什么是模板？如何实现？、

    创建类或者函数的蓝图或者公式，分为函数模板和类模板。

    **类模板，函数模板**

    - 模板参数列表不能为空；
    - 模板类型参数前必须使用关键字 class 或者 typename，在模板参数列表中这两个关键字含义相同，可互换使用。

    函数模板：通过定义一个函数模板，可以避免为每一种类型定义一个新函数。

    - 对于函数模板而言，**模板类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。**

    - 函数模板实例化：**当调用一个模板时，编译器用函数实参来推断模板实参，从而使用实参的类型来确定绑定到模板参数的类型。**

      ```cpp
      template <typename T>
      T add_fun(const T & tmp1, const T & tmp2){
          return tmp1 + tmp2;
      }
      ```

    类模板：类似函数模板，类模板以关键字 template 开始，后跟模板参数列表。但是，**编译器不能为类模板推断模板参数类型，需要在使用该类模板时，在模板名后面的尖括号中指明类型。**

    ```cpp
    template <typename T>
    class Complex{
    public:
        //构造函数
        Complex(T a, T b)
        {
            this->a = a;
            this->b = b;
        }
    
        //运算符重载
        Complex<T> operator+(Complex &c){
            Complex<T> tmp(this->a + c.a, this->b + c.b);
            cout << tmp.a << " " << tmp.b << endl;
            return tmp;
        }
    
    private:
        T a;
        T b;
    };
    Complex<int> a (10,20);//指明类型
    ```

59. 函数模板与类模板的区别？

    **实例化方式不同：**函数模板实例化由编译程序**在处理函数调用时自动完成**，**类模板实例化需要在程序中显式指定。**
    **实例化的结果不同**：函数模板实例化后是一个函数，类模板实例化后是一个类。
    默认参数：**类模板在模板参数列表中可以有默认参数。**
    **特化：函数模板只能全特化；而类模板可以全特化，也可以偏特化。**
    调用方式不同：**函数模板可以隐式调用，也可以显式调用；类模板只能显式调用。**
    函数模板调用方式举例：

    ```cpp
    cout << add_fun<int>(var1, var2); // 显式调用
    cout << add_fun(var3, var4); // 隐式调用
    ```

60. 什么是可变参数模板？

    可变参数模板：**接受可变数目参数的模板函数或模板类**。将可变数目的参数被称为参数包，包括模板参数包和函数参数包。

    ​	模板参数包：表示零个或多个模板参数；
    ​	函数参数包：表示零个或多个函数参数。
    用省略号来指出一个模板参数或函数参数表示一个包，在模板参数列表中，c**lass… 或 typename… 指出接下来的参数表示零个或多个类型的列表**；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。当**需要知道包中有多少元素时，可以使用 sizeof… 运算符。**

    ```cpp
    template <typename T, typename... Args> // Args 是模板参数包
    void foo(const T &t, const Args&... rest); // 可变参数模板，rest 是函数参数包
    
    template <typename T>
    void print_fun(const T &t){
        cout << t << endl; // 最后一个元素
    }
    
    template <typename T, typename... Args>
    void print_fun(const T &t, const Args &...args){
        cout << t << " ";
        print_fun(args...);
    }
    
    可变参数函数通常是递归的，第一个版本的 print_fun 负责终止递归并打印初始调用中的最后一个实参。第二个版本的 print_fun 是可变参数版本，打印绑定到 t 的实参，并用来调用自身来打印函数参数包中的剩余值。
    ```

61. 什么是模板特化？为什么特化？

    **模板特化的原因：模板并非对任何模板实参都合适、都能实例化**，某些情况下，**通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果**。因此，**当不希望使用模板版本时，可以定义类或者函数模板的一个特例化版本。**

    - 函数模板特化：将**函数模板中的全部类型进行特例化**，称为函数模板特化。
    - 类模板特化：将**类模板中的部分或全部类型进行特例化**，称为类模板特化。

    ```cpp
    //函数模板
    template <class T>
    bool compare(T t1, T t2){
        cout << "通用版本：";
        return t1 == t2;
    }
    
    template <> //函数模板特化
    bool compare(char *t1, char *t2){
        cout << "特化版本：";
        return strcmp(t1, t2) == 0;
    }
    ```

    定义函数模板的特化版本，**本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载**，函数模板特化并不影响函数匹配。

62. 泛型编程如何实现？

    

63. c++命名空间

    使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突。在C++中，变量、函数和类都是大量存在的。如果没有命名空间，这些变量、函数、类的名称将都存在于全局命名空间中，会导致很多冲突。比如，如果我们在自己的程序中定义了一个函functionA()，这将重写标准库中的functionA()函 数，这是因为这两个函数都是位于全局命名空间中的。

64. c++STL六大组件（容器，算法，迭代器，仿函数，适配器，空间配置器）

65. 大端、小端

    大端：高字节存放低地址

    小端：高字节存放高地址

    高有效位 → **12 34 56 78** → 低有效位
    **小端**： 低地址位 → **7 8 56 34 12** → 高地址位
    **大 端**： 低地址位 → **12 34 56 78** → 高地址位

66. 

1. Unordered_map实现原理？

   哈希表（数组）+链表/红黑树。
   底层使用hashtable+buket的实现原理，hashtable可以看作是一个数组 或者vector之类的连续内存存储结构（可以通过下标来快速定位时间复杂度为O(1)）处理hash冲突的方法就是在相同hash值的元素位置下面挂buket（桶），当数据量在8以内使用链表来实现桶，当数据量大于8 则自动转换为红黑树结构 也就是有序map的实现结构。
   
3. Hash_map与map

   hash_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。虽然对外部提供的函数和数据类型是一致的，但是其底层实现是完全不同的，map底层的数据结构是rb_tree(红黑树)而，hash_map却是哈希表来实现的。
   
11. 当哈希表容量很大甚至超限时，你会怎么处理呢?

    扩容。影响哈希表扩容的因素有两个，本身的容量和负载因子，当前的哈希表大小大于容量乘负载因子的时候，哈希表就需要扩容。

2. AVL树的插入、删除、查询的时间复杂度。

   AVL树是一种平衡的二叉搜索树。空二叉树是AVL树，如果T是AVL树，那么T的左右儿子也是AVL树，并且高度差小于等于1，AVL树的高度为O(logn)
   
5. Epoll的实现原理。

4. 多线程有什么优势呢，可和多进程以及单进程相比。

   一个进程可以包含多个线程，线程在进程的内部。(包含关系)
   进程之间的资源是独立的，线程之间的资源则是共享的。（资源是否独立共享）
   多个进程同时执行时，如果一个进程崩溃，一般不会影响其他进程，而同一进程内的多个线程之间，如果一个线程崩溃，很可能使得整个进程崩溃。一个进程崩溃一般不会影响另一个，但是线程崩溃可能造成整个进程崩溃
   进程的上下文切换速度比较慢，而线程的上下文切换速度比较快。（上下文切换速度）
   进程的创建/销毁/调度开销大，线程的创建/销毁/调度开销相对少很多。（开销）
   
7. c++转型: **const_cast**， **dynamic_cast**，**static_cast**，**reinterpret_cast**

   const_cast:去掉const属性，强制去掉常量属性，不能用于去掉变量的常量性，**只能用于去除指针或引用的常量性**，将常量指针转化为非常量指针或者将常量引用转化为非常量引用

   dynamic_cast:运行时，安全向下转型，父类向子类。**只能用于带有虚函数的基类或派生类的指针或者引用对象的转换**，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。

   static_cast:用于类层次之间的基类和派生类之间 指针或者引用 的转换（**不要求必须包含虚函数，但必须是有相互联系的类**），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 dynamic_cast 进行下行转换。

   reinterpret_cast:改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。
