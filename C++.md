# C++ 面经整理

1. c++ 程序编译过程
   预处理->编译，优化->汇编->链接
   预处理：(预处理器指令)宏展开，处理条件编译指令，#if,#ifdef等，#include指令,删除注释，加入行号和文件标识等，保留#pragma编译器指令
   编译优化：词法分析，语法分析，语义分析，代码优化，主要是生成汇编代码.s
   汇编：将汇编代码.s翻译成机器指令.o或.obj目标文件
   链接：产生.out或.exe可执行文件。（静态链接和动态链接）链接是将所有的.o文件和库（动态库、静态库）链接在一起，得到可以运行的可执行文件（Windows的.exe文件或Linux的.out文件）等 。静态链接是 将各个模块的obj和库链接成 **一个完整的可执行程序** ；而动态链接是程序在运行的时候寻找动态库的函数符号（重定位），即 **DLL不必被包含在最终的exe文件中** ；
   
2. 讲述一下c++内存的结构

   栈，堆，全局/静态存储区，常量存储区，代码区。

   - **栈**：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。栈从高地址向低地址增长。是一块连续的空间。栈一般分配几M大小的内存。
   - **堆**：动态申请的内存空间，就是由 malloc （new）分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。堆从低地址向高地址增长。一般可以分配几个G大小的内存。
   - 在堆栈之间有一个 共享区（文件映射区）
   - 全局区/静态存储区：存放全局变量和静态变量，程序运行结束操作系统自动释放
   - **代码区（.text 段）**：存放程序执行代码的一块内存区域。**只读，不允许修改**，但可以执行。编译后的二进制文件存放在这里。
   
3. 栈和堆的区别

   **申请方式的不同**。 栈由系统自动分配，而堆是人为申请开辟;
   **申请大小的不同**。 栈获得的空间较小，而堆获得的空间较大;
   **申请效率的不同**。 栈由系统自动分配，速度较快，而堆一般速度比较慢;
   **存储的内容不同**。堆一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。
   栈在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
   
4. 变量的区别

   **全局变量、局部变量、静态全局变量、静态局部变量**
   全局变量：定义在函数外面的变量。局部变量：函数内定义的变量。静态变量，前面加了static的变量。全局变量和静态变量存储在常量区（静态存储区）。局部变量存储在栈区。局部变量一般不初始化，全局变量和静态变量都初始化为0，有一个初始的值。
   对于C语言： 静态变量和全局变量均在**编译期进行初始化**，即初始化发生在任何代码执行之前。
   对于C++： 静态变量和全局变量**仅当首次被使用的时候才进行初始化**
   
5. 作用域

   全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。
   全局作用域。**全局变量**只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。会一直存在到程序结束。
   **静态全局变量：**全局作用域+文件作用域，所以无法在其他文件中使用。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
   **局部变量：**具有局部作用域。比如函数的参数，函数内的局部变量等等；它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被销毁，其所占用的内存也被收回。
   **静态局部变量：**具有局部作用域。它只被初始化一次， 直到程序结束。自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。
   
6. 内存对齐：

   什么是内存对齐？内存对齐的原则？为什么要内存对齐？有什么优点？
   内存对齐：编译器将程序中的每个“数据单元”安排在**字的整数倍**的地址指向的内存之中
   结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；
   结构体每个成员相对于结构体首地址的偏移量 （offset）都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；
   结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。

   主要是硬件设备的原因，某些硬件设备只能存取对齐数据。存取非对齐的数据可能会引起异常。

   提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取
   
7. 内存泄露

   失去了对某些内存的控制权。造成了内存的浪费。常指堆内存泄露，堆是动态分配的，用户控制，如果使用不当，比如因为异常未delete 数据，会产生内存泄露。
   
8. 防止内存泄露

   1. 内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。（说明：但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况）
   2. 智能指针。
   
9. 深拷贝与浅拷贝

   c++默认的拷贝构造函数是浅拷贝。当数据成员中没有指针时，浅拷贝是可行的；但**当数据成员中有指针时，如果采用简单的浅拷贝**，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。深拷贝会在**堆内存中另外申请空间来储存数据，而不是一个简单的赋值过程**，从而也就解决了指针悬挂的问题。

10. 虚拟内存

    物理内存：物理内存实际上是CPU中能直接寻址的地址线条数。由于物理内存是有限的，例如32位平台下，寻址的大小是4G，并且是固定的。内存很快就会被分配完，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的。

    虚拟内存：在进程创建的时候，系统都会给每个进程分配4G的内存空间，这其实是虚拟内存空间。进程得到的这4G虚拟内存，进程自身以为是一段连续的空间，而实际上，通常被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，需要的时候进行数据交换。

    ​	当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。
    ​	另外在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。

    ​	可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）

    优点：

    既然每个进程的内存空间都是一致而且固定的（32位平台下都是4G），所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际内存地址，这交给内核来完成映射关系。

    当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存

    在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。这样就可以有效地利用我们的物理内存

11. auto，decltype

    auto 关键字：自动类型推导，编译器会在 **编译期间** 通过初始值推导出变量的类型，通过 **auto 定义的变量必须有初始值。**

    decltype 是“declare type”的缩写，译为“声明类型”。和 auto 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto

    ```cpp
    auto var = val1+val2
    decltype (val1+val2) val = 0;
    ```

12. lambada表达式

    lambda 表达式，又被称为 lambda 函数或者 lambda 匿名函数。

    ```cpp
    [capture list] (parameter list) -> return type
    {
       function body;
    };
    
    ```

    - capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表，通常为空。
    - return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。

    ```cpp
    sort(arr,arr+4,[=](int x,int y)-> bool{ return x<y; })
    ```

13. 范围for语句

    ```cpp
    for(declaration:expression) {
    	statement
    }
    ```

    expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、vector ，string等，这些类型的共同特点是拥有能返回迭代器的 beign、end 成员。

    declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用 auto 类型说明符。

14. 

15. const与define区别

#define是在编译的**预处理阶段**起作用，而const是在 **编译、运行**的时候起作用
#define只是**简单的字符替换，没有类型检查,存在边界的错误；**const对应**数据类型，进行类型检查；**                                                                                                       #define只是进行展开，有多少地方使用，就替换多少次，**它定义的宏常量在内存中有若干个备份,占用代码段空间；**const定义的只读变量在程序运行过程中**只有一份备份，占用数据段空间。**

**const常量可以进行调试的**，**define是不能进行调试的**，因为在预编译阶段就已经替换掉了。                                                                                                                                                                                                              **const不足的地方，是与生俱来的，const不能重定义，而#define可以通过#undef取消某个符号的定义，再重新定义。**

**define可以用来防止头文件重复引用，而const不能;**

**const用于类成员变量的定义，只要一定义，不可修改。define 不可用于类成员变量的定义，但是可以用于全局变量。**

const采用一个普通的常量名称，define可以采用表达式作为名称；

1. Unordered_map实现原理？
2. 哈希表（数组）+链表/红黑树。
   底层使用hashtable+buket的实现原理，hashtable可以看作是一个数组 或者vector之类的连续内存存储结构（可以通过下标来快速定位时间复杂度为O(1)）处理hash冲突的方法就是在相同hash值的元素位置下面挂buket（桶），当数据量在8以内使用链表来实现桶，当数据量大于8 则自动转换为红黑树结构 也就是有序map的实现结构。
3. Hash_map与map

   hash_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。虽然对外部提供的函数和数据类型是一致的，但是其底层实现是完全不同的，map底层的数据结构是rb_tree(红黑树)而，hash_map却是哈希表来实现的。
11. 当哈希表容量很大甚至超限时，你会怎么处理呢?

    扩容。影响哈希表扩容的因素有两个，本身的容量和负载因子，当前的哈希表大小大于容量乘负载因子的时候，哈希表就需要扩容。
12. c++11新特性，比如你代码里出现的auto以及智能指针这些?

- 函数参数类型不能是 auto 类型；
- 类的成员变量不可以是 auto 类型。类的静态成员变量可以是 auto 类型的，但是需要使用 const 修饰，而且该变量的值在类内初始化

2. AVL树的插入、删除、查询的时间复杂度。

   AVL树是一种平衡的二叉搜索树。空二叉树是AVL树，如果T是AVL树，那么T的左右儿子也是AVL树，并且高度差小于等于1，AVL树的高度为O(logn)
3. Epoll的实现原理。
4. 多线程有什么优势呢，可和多进程以及单进程相比。

   一个进程可以包含多个线程，线程在进程的内部。(包含关系)
   进程之间的资源是独立的，线程之间的资源则是共享的。（资源是否独立共享）
   多个进程同时执行时，如果一个进程崩溃，一般不会影响其他进程，而同一进程内的多个线程之间，如果一个线程崩溃，很可能使得整个进程崩溃。一个进程崩溃一般不会影响另一个，但是线程崩溃可能造成整个进程崩溃
   进程的上下文切换速度比较慢，而线程的上下文切换速度比较快。（上下文切换速度）
   进程的创建/销毁/调度开销大，线程的创建/销毁/调度开销相对少很多。（开销）
5. C++ explicit关键字

   explicit关键字**只能用于修饰只有一个参数的类构造函数**, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).
   **如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了.**
   **除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效**, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数
6. c++智能指针

   智能指针是**RAII(Resource Acquisition Is Initialization，资源获取即初始化)**机制对普通指针进行的一层封装。这样使得智能指针的行为动作像一个指针，本质上却是一个对象，这样可以方便管理一个对象的生命周期。auto_ptr、unique_ptr、shared_ptr 和 weak_ptr。其中，auto_ptr 在 C++11已被摒弃，在C++17中已经移除不可用。
   unique_ptr**没有复制构造函数，不支持普通的拷贝和赋值操作**。因为unique_ptr独享被管理对象指针所有权。unique_ptr虽然不支持普通的拷贝和赋值操作，但却可以**将所有权进行转移，使用std::move方法**即可。
   unique**最常见的使用场景，就是替代原始指针，为动态申请的资源提供异常安全保证**。
   shared_ptr**使用引用计数实现对同一块内存的多个引用**。在最后一个引用被释放时，指向的内存才释放。
   当对象的所有权需要共享(share)时，share_ptr**可以进行赋值拷贝**。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。
**
    不能将一个原始指针初始化多个shared_ptr**，因为p1,p2都要进行析构删除，这样会造成原始指针p0被删除两次，自然要报错。

```cpp
void f2() {
    int *p0 = new int(1);
    shared_ptr<int> p1(p0);
    shared_ptr<int> p2(p0);
    cout<<*p1<<endl;
}
```

**
    shared_ptr最大的坑就是循环引用**，为避免循环引用导致的内存泄露，就需要使用 weak_ptr。**weak_ptr 并不拥有其指向的对象**，也就是说，让 **weak_ptr 指向 shared_ptr 所指向对象，对象的引用计数并不会增加**。**因此不能保证所管理的对象一定存在。**用于检查所管理的资源是否已经被释放（**expired()**函数），以及协助 shared_ptr 防止循环引用。
    shared_ptr 的**引用计数是通过原子操作**实现的，即**多线程环境下可以保证线程安全**。在 std::shared_ptr 中，使用 **std::atomic 类型来实现引用计数的原子操作**。该类型是 **C++11 标准库**中提供的，支持原子类型加、减、读、写等操作

**
    智能指针指向的对象的线程安全问题，智能指针没有做任何保障**

**
    1）同一个shared_ptr被多个线程“读”是安全的；**

**
    2）同一个shared_ptr被多个线程“写”是不安全的；**

**
    3）共享引用计数的不同的shared_ptr被多个线程”写“ 是安全的；**

读的时候，比如把智能指针赋值给另一个智能指针，这个不会修改原始指针的指向，只会修改引用计数，而修改引用计数这个操作是原子的，所以读操作就是线程安全的；

写的时候，需要做两个事情，先修改原始指针然后再引用计数，这两个步骤是没有加锁保护的，所以这两个操作加起来就不是原子的。比如swap函数：

7. 左值引用，右值引用，万能引用。

   左值和右值都是表达数据的表达式，右值是不可取地址的，比如常数，x+y，以及函数的返回值。
   左值引用和右值引用(c++11)就是分别给左右值取别名。右值引用引用右值，把右值存储在一个特定的位置，然后可以对这个右值引用变量取地址。
   左值引用不能之间引用右值，但是const左值引用既可以引用左值，也可以引用右值。
   右值引用可以引用被move的左值。std::move将左值强制转换为右值.
   解决传值返回和拷贝问题。
   移动语义：将一个对象的资源移动到另一个对象。
   移动构造直接转移资源，比拷贝构造效率高。拷贝构造，深拷贝需要开辟空间。
8. c++转型: **const_cast**， **dynamic_cast**，**static_cast**，**reinterpret_cast**
9. c++面向对象封装，继承，多态

* 封装：类，属性和方法都在类里
* 继承：支持多继承
* 多态：相同的方法调用，不同的实现方式，一个接口，多种方法
  * 虚函数，方法重写（动态多态）通过基类类型的引用或指针调用虚函数
  * 静态多态：编译期间的多态，编译器根据函数实参的类型推断出要调用那个函数（函数重载，函数模板（泛型编程））
