# C++ 面经整理

1. c++ 程序编译过程
   预处理->编译，优化->汇编->链接
   预处理：(预处理器指令)宏展开，处理条件编译指令，#if,#ifdef等，#include指令,删除注释，加入行号和文件标识等，保留#pragma编译器指令
   编译优化：词法分析，语法分析，语义分析，代码优化，主要是生成汇编代码.s
   汇编：将汇编代码.s翻译成机器指令.o或.obj目标文件
   链接：产生.out或.exe可执行文件。（静态链接和动态链接）链接是将所有的.o文件和库（动态库、静态库）链接在一起，得到可以运行的可执行文件（Windows的.exe文件或Linux的.out文件）等 。静态链接是 将各个模块的obj和库链接成 **一个完整的可执行程序** ；而动态链接是程序在运行的时候寻找动态库的函数符号（重定位），即 **DLL不必被包含在最终的exe文件中** ；

2. 讲述一下c++内存的结构
   栈，堆，全局/静态存储区，常量存储区，代码区。

   - **栈**：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。栈从高地址向低地址增长。是一块连续的空间。栈一般分配几M大小的内存。
   - **堆**：动态申请的内存空间，就是由 malloc （new）分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。堆从低地址向高地址增长。一般可以分配几个G大小的内存。
   - 在堆栈之间有一个 共享区（文件映射区）
   - 全局区/静态存储区：存放全局变量和静态变量，程序运行结束操作系统自动释放
   - **代码区（.text 段）**：存放程序执行代码的一块内存区域。**只读，不允许修改**，但可以执行。编译后的二进制文件存放在这里。

3. 栈和堆的区别

   **申请方式的不同**。 栈由系统自动分配，而堆是人为申请开辟;

   **申请大小的不同**。 栈获得的空间较小，而堆获得的空间较大;

   **申请效率的不同**。 栈由系统自动分配，速度较快，而堆一般速度比较慢;

    **存储的内容不同**。堆一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。

   栈在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

4. const与define区别

（1）就起作用的阶段而言： #define是在编译的**预处理阶段**起作用，而const是在 **编译、运行**的时候起作用

（2）就起作用的方式而言： #define只是**简单的字符替换，没有类型检查,存在边界的错误；**const对应**数据类型，进行类型检查；**                                                                                                                                                                                                          （3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，**它定义的宏常量在内存中有若干个备份,占用代码段空间；**const定义的只读变量在程序运行过程中**只有一份备份，占用数据段空间。**

（4）从代码调试的方便程度而言： **const常量可以进行调试的**，**define是不能进行调试的**，因为在预编译阶段就已经替换掉了。                                                                                                                                                                                                                    （5）从是否可以再定义的角度而言： **const不足的地方，是与生俱来的，const不能重定义，而#define可以通过#undef取消某个符号的定义，再重新定义。**

（6）从某些特殊功能而言： **define可以用来防止头文件重复引用，而const不能;**

（7）从用于类中来看：**const用于类成员变量的定义，只要一定义，不可修改。define 不可用于类成员变量的定义，但是可以用于全局变量。**

（8）const采用一个普通的常量名称，define可以采用表达式作为名称；

2. Unordered_map实现原理？

   哈希表（数组）+链表/红黑树。

   底层使用hashtable+buket的实现原理，hashtable可以看作是一个数组 或者vector之类的连续内存存储结构（可以通过下标来快速定位时间复杂度为O(1)）处理hash冲突的方法就是在相同hash值的元素位置下面挂buket（桶），当数据量在8以内使用链表来实现桶，当数据量大于8 则自动转换为红黑树结构 也就是有序map的实现结构。
3. Hash_map与map

   hash_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。虽然对外部提供的函数和数据类型是一致的，但是其底层实现是完全不同的，map底层的数据结构是rb_tree(红黑树)而，hash_map却是哈希表来实现的。
4. 当哈希表容量很大甚至超限时，你会怎么处理呢?

   扩容。影响哈希表扩容的因素有两个，本身的容量和负载因子，当前的哈希表大小大于容量乘负载因子的时候，哈希表就需要扩容。
5. c++11新特性，比如你代码里出现的auto以及智能指针这些?

- 函数参数类型不能是 auto 类型；
- 类的成员变量不可以是 auto 类型。类的静态成员变量可以是 auto 类型的，但是需要使用 const 修饰，而且该变量的值在类内初始化

2. AVL树的插入、删除、查询的时间复杂度。

   AVL树是一种平衡的二叉搜索树。空二叉树是AVL树，如果T是AVL树，那么T的左右儿子也是AVL树，并且高度差小于等于1，AVL树的高度为O(logn)
3. Epoll的实现原理。
4. 讲述一下内存的结构。

   c++

   **栈区**：

   1. 作用：保存局部变量、函数调用参数等
   2. 生命周期：只在函数范围内存在，当函数运行结束时自动销毁

   **堆区**：

   1. 作用：保存new的对象
   2. 生命周期：遇见delete结束，如果没有主动调用delete则在程序结束后由OS自动回收

   **数据区**：

   通常又分为全局区（静态区）和 常量区

   全局区（静态区）

   1. 作用：存放全局变量和static静态变量，已经初始化的在.data区域，未初始化的在.bss区域
   2. 生命周期：程序结束后由OS释放

   常量区

   1. 作用：存放不可修改的常量
   2. 生命周期：程序结束后由OS释放

   **代码区**：

   存放程序执行代码
5. 多线程有什么优势呢，可和多进程以及单进程相比。

   一个进程可以包含多个线程，线程在进程的内部。(包含关系)

   进程之间的资源是独立的，线程之间的资源则是共享的。（资源是否独立共享）

   多个进程同时执行时，如果一个进程崩溃，一般不会影响其他进程，而同一进程内的多个线程之间，如果一个线程崩溃，很可能使得整个进程崩溃。一个进程崩溃一般不会影响另一个，但是线程崩溃可能造成整个进程崩溃

   进程的上下文切换速度比较慢，而线程的上下文切换速度比较快。（上下文切换速度）

   进程的创建/销毁/调度开销大，线程的创建/销毁/调度开销相对少很多。（开销）
6. C++ explicit关键字

   1. explicit关键字**只能用于修饰只有一个参数的类构造函数**, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).
   2. **如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了.**
   3. **除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效**, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数
7. c++智能指针

   智能指针是**RAII(Resource Acquisition Is Initialization，资源获取即初始化)**机制对普通指针进行的一层封装。这样使得智能指针的行为动作像一个指针，本质上却是一个对象，这样可以方便管理一个对象的生命周期。auto_ptr、unique_ptr、shared_ptr 和 weak_ptr。其中，auto_ptr 在 C++11已被摒弃，在C++17中已经移除不可用。

   unique_ptr**没有复制构造函数，不支持普通的拷贝和赋值操作**。因为unique_ptr独享被管理对象指针所有权。unique_ptr虽然不支持普通的拷贝和赋值操作，但却可以**将所有权进行转移，使用std::move方法**即可。

   unique**最常见的使用场景，就是替代原始指针，为动态申请的资源提供异常安全保证**。

   shared_ptr**使用引用计数实现对同一块内存的多个引用**。在最后一个引用被释放时，指向的内存才释放。

   当对象的所有权需要共享(share)时，share_ptr**可以进行赋值拷贝**。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。

**
    不能将一个原始指针初始化多个shared_ptr**，因为p1,p2都要进行析构删除，这样会造成原始指针p0被删除两次，自然要报错。

```cpp
void f2() {
    int *p0 = new int(1);
    shared_ptr<int> p1(p0);
    shared_ptr<int> p2(p0);
    cout<<*p1<<endl;
}
```

**
    shared_ptr最大的坑就是循环引用**，为避免循环引用导致的内存泄露，就需要使用 weak_ptr。**weak_ptr 并不拥有其指向的对象**，也就是说，让 **weak_ptr 指向 shared_ptr 所指向对象，对象的引用计数并不会增加**。**因此不能保证所管理的对象一定存在。**用于检查所管理的资源是否已经被释放（**expired()**函数），以及协助 shared_ptr 防止循环引用。

    shared_ptr 的**引用计数是通过原子操作**实现的，即**多线程环境下可以保证线程安全**。在 std::shared_ptr 中，使用 **std::atomic 类型来实现引用计数的原子操作**。该类型是 **C++11 标准库**中提供的，支持原子类型加、减、读、写等操作

**
    智能指针指向的对象的线程安全问题，智能指针没有做任何保障**

**
    1）同一个shared_ptr被多个线程“读”是安全的；**

**
    2）同一个shared_ptr被多个线程“写”是不安全的；**

**
    3）共享引用计数的不同的shared_ptr被多个线程”写“ 是安全的；**

    读的时候，比如把智能指针赋值给另一个智能指针，这个不会修改原始指针的指向，只会修改引用计数，而修改引用计数这个操作是原子的，所以读操作就是线程安全的；写的时候，需要做两个事情，先修改原始指针然后再引用计数，这两个步骤是没有加锁保护的，所以这两个操作加起来就不是原子的。比如swap函数：

9. 左值引用，右值引用，万能引用。
10. c++转型: **const_cast**， **dynamic_cast**，**static_cast**，**reinterpret_cast**
11. c++面向对象封装，继承，多态

* 封装：类，属性和方法都在类里
* 继承：支持多继承
* 多态：相同的方法调用，不同的实现方式，一个接口，多种方法
  * 虚函数，方法重写（动态多态）通过基类类型的引用或指针调用虚函数
  * 静态多态：编译期间的多态，编译器根据函数实参的类型推断出要调用那个函数（函数重载，函数模板（泛型编程））
