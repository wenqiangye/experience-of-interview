# C++ 面经整理

1. const与define区别

（1）就起作用的阶段而言： #define是在编译的**预处理阶段**起作用，而const是在 **编译、运行**的时候起作用                                             

（2）就起作用的方式而言： #define只是**简单的字符替换，没有类型检查,存在边界的错误；**const对应**数据类型，进行类型检查；**                                                                                                                                                                                                          （3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，**它定义的宏常量在内存中有若干个备份,占用代码段空间；**const定义的只读变量在程序运行过程中**只有一份备份，占用数据段空间。**   

（4）从代码调试的方便程度而言： **const常量可以进行调试的**，**define是不能进行调试的**，因为在预编译阶段就已经替换掉了。                                                                                                                                                                                                                    （5）从是否可以再定义的角度而言： **const不足的地方，是与生俱来的，const不能重定义，而#define可以通过#undef取消某个符号的定义，再重新定义。**

（6）从某些特殊功能而言： **define可以用来防止头文件重复引用，而const不能;**

（7）从用于类中来看：**const用于类成员变量的定义，只要一定义，不可修改。define 不可用于类成员变量的定义，但是可以用于全局变量。**

（8）const采用一个普通的常量名称，define可以采用表达式作为名称；

2. Unordered_map实现原理？

   哈希表（数组）+链表/红黑树。

   底层使用hashtable+buket的实现原理，hashtable可以看作是一个数组 或者vector之类的连续内存存储结构（可以通过下标来快速定位时间复杂度为O(1)）处理hash冲突的方法就是在相同hash值的元素位置下面挂buket（桶），当数据量在8以内使用链表来实现桶，当数据量大于8 则自动转换为红黑树结构 也就是有序map的实现结构。

3. Hash_map与map

   hash_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。虽然对外部提供的函数和数据类型是一致的，但是其底层实现是完全不同的，map底层的数据结构是rb_tree(红黑树)而，hash_map却是哈希表来实现的。

4. 当哈希表容量很大甚至超限时，你会怎么处理呢?

5. c++11新特性，比如你代码里出现的auto以及智能指针这些?

6. AVL树的插入、删除、查询的时间复杂度。

7. Epoll的实现原理。

8. 讲述一下内存的结构。

9. 多线程下，它们使用了内存中哪些区域?

10. 多线程有什么优势呢，可和多进程以及单进程相比。

11. Tcp和Udp各有什么劣势。

12. 在游戏中，当我们使用Udp去支持很高的流量场景时，但又不想出现丢包的情况，你会怎么去处理呢?

1. C++ explicit关键字

explicit关键字**只能用于修饰只有一个参数的类构造函数**, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).

**如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了.**

**除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效**, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数

2. c++智能指针

智能指针是**RAII(Resource Acquisition Is Initialization，资源获取即初始化)**机制对普通指针进行的一层封装。这样使得智能指针的行为动作像一个指针，本质上却是一个对象，这样可以方便管理一个对象的生命周期。auto_ptr、unique_ptr、shared_ptr 和 weak_ptr。其中，auto_ptr 在 C++11已被摒弃，在C++17中已经移除不可用。

unique_ptr**没有复制构造函数，不支持普通的拷贝和赋值操作**。因为unique_ptr独享被管理对象指针所有权。unique_ptr虽然不支持普通的拷贝和赋值操作，但却可以**将所有权进行转移，使用std::move方法**即可。

unique**最常见的使用场景，就是替代原始指针，为动态申请的资源提供异常安全保证**。

shared_ptr **使用引用计数实现对同一块内存的多个引用**。在最后一个引用被释放时，指向的内存才释放。

当对象的所有权需要共享(share)时，share_ptr**可以进行赋值拷贝**。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。

**不能将一个原始指针初始化多个shared_ptr**，因为p1,p2都要进行析构删除，这样会造成原始指针p0被删除两次，自然要报错。

```cpp
void f2() {
    int *p0 = new int(1);
    shared_ptr<int> p1(p0);
    shared_ptr<int> p2(p0);
    cout<<*p1<<endl;
}
```

**shared_ptr最大的坑就是循环引用**，为避免循环引用导致的内存泄露，就需要使用 weak_ptr。**weak_ptr 并不拥有其指向的对象**，也就是说，让 **weak_ptr 指向 shared_ptr 所指向对象，对象的引用计数并不会增加**。**因此不能保证所管理的对象一定存在。**用于检查所管理的资源是否已经被释放（**expired()**函数），以及协助 shared_ptr 防止循环引用。

shared_ptr 的**引用计数是通过原子操作**实现的，即**多线程环境下可以保证线程安全**。在 std::shared_ptr 中，使用 **std::atomic 类型来实现引用计数的原子操作**。该类型是 **C++11 标准库**中提供的，支持原子类型加、减、读、写等操作

**智能指针指向的对象的线程安全问题，智能指针没有做任何保障**

**1）同一个shared_ptr被多个线程“读”是安全的；**

**2）同一个shared_ptr被多个线程“写”是不安全的；**

**3）共享引用计数的不同的shared_ptr被多个线程”写“ 是安全的；**

读的时候，比如把智能指针赋值给另一个智能指针，这个不会修改原始指针的指向，只会修改引用计数，而修改引用计数这个操作是原子的，所以读操作就是线程安全的；写的时候，需要做两个事情，先修改原始指针然后再引用计数，这两个步骤是没有加锁保护的，所以这两个操作加起来就不是原子的。比如swap函数：

3. 左值引用，右值引用，万能引用。

