1. const与define区别

（1）就起作用的阶段而言： #define是在编译的**预处理阶段**起作用，而const是在 **编译、运行**的时候起作用                                             

（2）就起作用的方式而言： #define只是**简单的字符替换，没有类型检查,存在边界的错误；**const对应**数据类型，进行类型检查；**                                                                                                                                                                                                          （3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，**它定义的宏常量在内存中有若干个备份,占用代码段空间；**const定义的只读变量在程序运行过程中**只有一份备份，占用数据段空间。**   

（4）从代码调试的方便程度而言： **const常量可以进行调试的**，**define是不能进行调试的**，因为在预编译阶段就已经替换掉了。                                                                                                                                                                                                                    （5）从是否可以再定义的角度而言： **const不足的地方，是与生俱来的，const不能重定义，而#define可以通过#undef取消某个符号的定义，再重新定义。**

（6）从某些特殊功能而言： **define可以用来防止头文件重复引用，而const不能;**

（7）从用于类中来看：**const用于类成员变量的定义，只要一定义，不可修改。define 不可用于类成员变量的定义，但是可以用于全局变量。**

（8）const采用一个普通的常量名称，define可以采用表达式作为名称；

2. Unordered_map实现原理？

   哈希表（数组）+链表/红黑树。

   底层使用hashtable+buket的实现原理，hashtable可以看作是一个数组 或者vector之类的连续内存存储结构（可以通过下标来快速定位时间复杂度为O(1)）处理hash冲突的方法就是在相同hash值的元素位置下面挂buket（桶），当数据量在8以内使用链表来实现桶，当数据量大于8 则自动转换为红黑树结构 也就是有序map的实现结构。

3. Hash_map与map

   hash_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。虽然对外部提供的函数和数据类型是一致的，但是其底层实现是完全不同的，map底层的数据结构是rb_tree(红黑树)而，hash_map却是哈希表来实现的。

4. 当哈希表容量很大甚至超限时，你会怎么处理呢?

5. c++11新特性，比如你代码里出现的auto以及智能指针这些?

6. AVL树的插入、删除、查询的时间复杂度。

7. Epoll的实现原理。

8. 讲述一下内存的结构。

9. 多线程下，它们使用了内存中哪些区域?

10. 多线程有什么优势呢，可和多进程以及单进程相比。

11. Tcp和Udp各有什么劣势。

12. 在游戏中，当我们使用Udp去支持很高的流量场景时，但又不想出现丢包的情况，你会怎么去处理呢?
    ​

    ​